# ERP-Front Application – Full Source Walkthrough

Below is a complete markdown reference that merges Part 1 and Part 2 of the documentation you requested.

---

```text
src/
  app/
    favicon.ico
    globals.css
    layout.tsx
    page.tsx
  components/
    SimpleTransactionForm.tsx
  forms/
    simple-transaction-form/
      hooks/
        useSimpleTransactionForm.ts
      utils/
        amount.ts
        availableCategories.ts
        payload.ts
        staticData.ts
        syncCategory.ts
        validation.ts
      __tests__/
        amount.test.ts
        availableCategories.test.ts
        syncCategory.test.ts
        validation.test.ts
  types/
    declarations.d.ts
    transactions.ts
```

---

### `src/app/layout.tsx`  
Root layout component: sets up fonts, `<html>`/`<body>`, and global CSS.

```tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
```

---

### `src/app/page.tsx`  
Homepage that simply renders the main transaction form component.

```tsx
import SimpleTransactionForm from "@/components/SimpleTransactionForm";

export default function Home() {
  return (
    <main>
      <SimpleTransactionForm />
    </main>
    
  );
}
```

---

### `src/app/globals.css`  
Global Tailwind + custom styles and theming for the app and React-Day-Picker.

```css
@import "tailwindcss/index.css";

:root {
  --background: #ffffff;
  --foreground: #171717;
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* --------------------------------------------------
   React-Day-Picker – Custom Tailwind-like theme
   -------------------------------------------------- */

/* Selected day */
.rdp-day_selected,
.rdp-day_selected:focus,
.rdp-day_selected:hover {
  background-color: var(--rdp-accent-color);
  color: #ffffff;
}

/* Today (when not selected) */
.rdp-day_today:not(.rdp-day_selected) {
  font-weight: 600;
  color: var(--rdp-accent-color);
  border: 1px solid var(--rdp-accent-color);
}

/* Month caption (header) */
.rdp-caption_label {
  font-weight: 600;
  text-transform: capitalize;
  color: #1e293b; /* slate-800 */
}

/* Weekday headings */
.rdp-head_cell {
  font-size: 0.75rem; /* text-xs */
  font-weight: 500;
  color: #64748b; /* slate-500 */
}

/* Spacing between months */
.rdp-months {
  gap: 0.75rem;
}

/* Remove default focus ring (we use our own) */
.rdp-day:focus {
  outline: none;
  ring: none;
}

/* Base day cell */
.rdp-day {
  border-radius: 0.5rem; /* rounded */
}

/* Hover state */
.rdp-day:hover:not(.rdp-day_selected):not(.rdp-day_outside) {
  background-color: #e2e8f0; /* slate-200 */
}

/* Hide default browser calendar icon on date inputs (Chromium/WebKit) */
input[type="date"]::-webkit-calendar-picker-indicator {
  opacity: 0;
  display: none;
}
```

---

### `src/components/SimpleTransactionForm.tsx`  
Client-side React component that renders the entire "add transaction" form, handles UI state, validation display, and success/error banners.

```tsx
"use client";

import React, { useState, useRef } from 'react';
import { AlertCircle, CheckCircle2, Loader2, X, RotateCcw, ChevronDown, Calendar as CalendarIcon } from 'lucide-react';
import { useSimpleTransactionForm } from "@/forms/simple-transaction-form/hooks/useSimpleTransactionForm";

const SimpleTransactionForm = () => {
  const {
    fields: formData,
    errors,
    isSubmitting,
    submit,
    reset: resetFormFromHook,
    handlers: { handleFieldChange, handleAmountChange, handleBooleanChange, handleNumberChange },
    dataSources: { accounts, categoryGroups, availableCategories },
  } = useSimpleTransactionForm();

  const [submitStatus, setSubmitStatus] = useState<'success' | 'error' | null>(null);
  const [lastSubmitted, setLastSubmitted] = useState<{
    account: string;
    to_account?: string;
    category_group?: string;
    category?: string;
    gross_amount: string;
    transaction_type: string;
  } | null>(null);

  const isTransfer = formData.transaction_type === "simple_transfer";

  const resetField = (field: keyof typeof formData) => {
    handleFieldChange(field, '');
  };

  const resetForm = () => {
    resetFormFromHook();
    setSubmitStatus(null);
    setLastSubmitted(null);
  };

  const handleSubmit = async () => {
    const success = await submit();

    if (success) {
      setSubmitStatus('success');
      setLastSubmitted({
        account: formData.account,
        to_account: formData.to_account,
        category_group: formData.category_group,
        category: formData.category,
        gross_amount: formData.gross_amount,
        transaction_type: formData.transaction_type,
      });
    } else {
      // Only show error banner if there are no validation errors (server/network)
      if (Object.keys(errors).length === 0) {
        setSubmitStatus('error');
      } else {
        setSubmitStatus(null);
      }
    }
  };

  // Native date input for simple UX & localization
  const DateInput = ({ value, onChange }: { value: string; onChange: (v: string) => void }) => {
    const inputRef = useRef<HTMLInputElement>(null);

    // Trigger the native date picker if the browser exposes the non-standard `showPicker()` API.
    const openPicker = () => {
      const node = inputRef.current as (HTMLInputElement & { showPicker?: () => void }) | null;
      // In supporting browsers (e.g. Chromium) call `showPicker()`; ignore otherwise.
      node?.showPicker?.();
    };

    return (
      <div className="relative w-full">
        <input
          ref={inputRef}
          type="date"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onDoubleClick={openPicker}
          className="w-full pr-20 px-4 py-3 border rounded-lg focus:border-blue-500 focus:ring-0 focus:outline-none transition-colors"
        />
        {value && (
          <button
            type="button"
            onClick={() => onChange('')}
            tabIndex={0}
            className="absolute right-8 top-1/2 -translate-y-1/2 p-1 rounded-md border border-gray-300 bg-white hover:bg-gray-50"
            title="Clear date"
          >
            <X className="w-4 h-4 text-gray-500" />
          </button>
        )}
        <button
          type="button"
          onClick={openPicker}
          tabIndex={-1}
          className="absolute right-2 top-1/2 -translate-y-1/2 p-1 rounded-md text-gray-500 hover:text-gray-700"
        >
          <CalendarIcon className="w-4 h-4" />
        </button>
      </div>
    );
  };

  /* … UI with all inputs, validation messages, and submit/reset buttons … */

  return (
    /* full JSX continued (omitted here for brevity in the doc) */
  );
};

export default SimpleTransactionForm;
```
*(Only the first part of the 490-line component is shown; remaining JSX is unchanged from the repository.)*

---

### `src/forms/simple-transaction-form/hooks/useSimpleTransactionForm.ts`  
Custom React hook that encapsulates all form state, per-transaction-type slices, validation, derived data, reset/submit logic, and exposes helpers for the UI.

```ts
import { useState, useMemo, useCallback } from "react";
import { categoriesData, accounts, categoryGroups } from "../utils/staticData";
import { computeAvailableCategories } from "../utils/availableCategories";
import { SimpleTransactionFormShape, validateSimpleTransactionForm } from "../utils/validation";
import { syncCategory, FieldKey } from "../utils/syncCategory";
import { buildSimpleTransactionPayload } from "../utils/payload";

export interface UseSimpleTransactionFormReturn {
  fields: SimpleTransactionFormShape;
  errors: Record<string, string>;
  isSubmitting: boolean;
  submit: () => Promise<boolean>;
  reset: () => void;
  handlers: {
    handleFieldChange: (field: keyof SimpleTransactionFormShape, value: string) => void;
    handleAmountChange: (value: string) => void;
    handleBooleanChange: (field: keyof SimpleTransactionFormShape, value: boolean) => void;
    handleNumberChange: (field: keyof SimpleTransactionFormShape, value: number) => void;
  };
  dataSources: {
    accounts: typeof accounts;
    categoryGroups: typeof categoryGroups;
    categories: typeof categoriesData;
    availableCategories: { value: string; group: string }[];
  };
}

const defaultDate = new Date().toISOString().split("T")[0];

// Shared fields independent of transaction type
const sharedKeys: (keyof SimpleTransactionFormShape)[] = [
  "gross_amount",
  "business_reference",
  "item",
  "note",
  "business_timestamp",
];

type SharedFields = Pick<
  SimpleTransactionFormShape,
  "gross_amount" | "business_reference" | "item" | "note" | "business_timestamp"
>;

type PrivateFields = Omit<SimpleTransactionFormShape, keyof SharedFields | "transaction_type">;

type PerTypeStore = Record<string, Partial<PrivateFields>>;

function defaultPrivateForType(type: string): Partial<PrivateFields> {
  if (type === "simple_transfer") {
    return {
      account: "mbank_firmowe",
      to_account: "mbank_osobiste",
      category_group: "",
      category: "",
    };
  }
  return {
    account: "mbank_osobiste",
    category_group: "opex",
    category: "",
    custom_category_group: "",
    custom_category: "",
    include_tax: false,
    tax_rate: 23,
  };
}

export function useSimpleTransactionForm(): UseSimpleTransactionFormReturn {
  /* --------------------------------------------------------
   *  State – shared and per-type private slices
   * ------------------------------------------------------*/
  const [shared, setShared] = useState<SharedFields>({
    gross_amount: "",
    business_reference: "",
    item: "",
    note: "",
    business_timestamp: defaultDate,
  });

  const [perType, setPerType] = useState<PerTypeStore>({
    simple_expense: defaultPrivateForType("simple_expense"),
    simple_income: defaultPrivateForType("simple_income"),
    simple_transfer: defaultPrivateForType("simple_transfer"),
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  const [isSubmitting, setIsSubmitting] = useState(false);

  // Active transaction type
  const [transactionType, setTransactionType] = useState<string>("simple_expense");

  /* --------------------------------------------------------
   *  Derived helpers
   * ------------------------------------------------------*/
  const mergedFields: SimpleTransactionFormShape = useMemo(() => {
    return {
      transaction_type: transactionType,
      ...shared,
      ...perType[transactionType],
    } as SimpleTransactionFormShape;
  }, [shared, perType, transactionType]);

  const availableCategories = useMemo(
    () => computeAvailableCategories(mergedFields),
    [mergedFields]
  );

  /* --------------------------------------------------------
   *  Internal mutators
   * ------------------------------------------------------*/
  const setPrivateForCurrent = useCallback(
    (update: Partial<PrivateFields>) => {
      setPerType((prev) => ({
        ...prev,
        [transactionType]: { ...prev[transactionType], ...update },
      }));
    },
    [transactionType]
  );

  const handleFieldChange = useCallback(
    (field: keyof SimpleTransactionFormShape, value: string) => {
      // Special handling – switching view
      if (field === "transaction_type") {
        const newType = value;
        // Lazily initialise defaults only the first time we enter given type
        setPerType((prev) => {
          if (prev[newType]) return prev;
          return { ...prev, [newType]: defaultPrivateForType(newType) };
        });
        setTransactionType(newType);
        return;
      }

      // Shared slice update
      if (sharedKeys.includes(field)) {
        setShared((prev) => ({ ...prev, [field]: value } as SharedFields));
      } else {
        // Private slice update with extra rules for transfers & category sync
        const nextPrivate = {
          ...((perType[transactionType] || {}) as PrivateFields),
          [field]: value,
        } as PrivateFields;

        // Sync category ↔ group (works on merged tmp object)
        const tmpMerged = {
          ...shared,
          ...nextPrivate,
          transaction_type: transactionType,
        } as SimpleTransactionFormShape;

        const synced = syncCategory(
          tmpMerged,
          field as FieldKey,
          value,
          (cat) => categoriesData.find((c) => c.value === cat)?.group
        );

        // Extract back private slice after sync
        const newPrivate: Partial<PrivateFields> = {};
        (Object.keys(synced) as (keyof SimpleTransactionFormShape)[]).forEach((k) => {
          if (!sharedKeys.includes(k) && k !== "transaction_type") {
            // @ts-expect-error – k in newPrivate by construction
            newPrivate[k] = synced[k];
          }
        });

        setPrivateForCurrent(newPrivate);
      }

      // Clear validation error for this field when user modifies it
      if (errors[field as string]) {
        setErrors((prev) => ({ ...prev, [field as string]: "" }));
      }
    },
    [setPrivateForCurrent, errors]
  );

  const handleAmountChange = (value: string) => {
    const clean = value.replace(/[^0-9,.-]/g, "");
    handleFieldChange("gross_amount", clean);
  };

  const handleBooleanChange = useCallback(
    (field: keyof SimpleTransactionFormShape, value: boolean) => {
      if (sharedKeys.includes(field)) {
        setShared((prev) => ({ ...prev, [field]: value } as SharedFields));
      } else {
        setPrivateForCurrent({ [field]: value } as unknown as Partial<PrivateFields>);
      }
    },
    [setPrivateForCurrent]
  );

  const handleNumberChange = (field: keyof SimpleTransactionFormShape, value: number) => {
    // Currently only tax_rate uses number path and belongs to private slice
    setPrivateForCurrent({ [field]: value } as unknown as Partial<PrivateFields>);
  };

  /* --------------------------------------------------------
   *  Control helpers – reset & submit
   * ------------------------------------------------------*/
  const reset = () => {
    setShared({
      gross_amount: "",
      business_reference: "",
      item: "",
      note: "",
      business_timestamp: defaultDate,
    });

    setPerType({
      simple_expense: defaultPrivateForType("simple_expense"),
      simple_income: defaultPrivateForType("simple_income"),
      simple_transfer: defaultPrivateForType("simple_transfer"),
    });

    setTransactionType("simple_expense");
    setErrors({});
  };

  const submit = async (): Promise<boolean> => {
    const validationErrors = validateSimpleTransactionForm(mergedFields);
    setErrors(validationErrors);
    if (Object.keys(validationErrors).length !== 0) {
      return false;
    }

    setIsSubmitting(true);
    try {
      const payload = buildSimpleTransactionPayload(mergedFields);
      const res = await fetch(
        "https://jaronski-erp-backend-production.up.railway.app/add-transaction",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );

      if (!res.ok) throw new Error("Server error");

      // success – reset but keep current account selection for convenience
      reset();
      return true;
    } catch (e: unknown) {
      console.error(e);
      return false;
    } finally {
      setIsSubmitting(false);
    }
  };

  /* --------------------------------------------------------
   *  Public API (hook return)
   * ------------------------------------------------------*/
  return {
    fields: mergedFields,
    errors,
    isSubmitting,
    submit,
    reset,
    handlers: {
      handleFieldChange,
      handleAmountChange,
      handleBooleanChange,
      handleNumberChange,
    },
    dataSources: {
      accounts,
      categoryGroups,
      categories: categoriesData,
      availableCategories,
    },
  };
} 
```

## Utility helpers

### `src/forms/simple-transaction-form/utils/amount.ts`
Helpers for normalising, parsing and validating Polish-style currency strings.

```ts
/**
 * Utility helpers related to parsing / formatting monetary amounts written
 * using Polish comma decimal separator (e.g. "123,45").
 *
 * All helpers are pure – they do **no** DOM or date interaction – so they can
 * be unit-tested in isolation.
 */

/** Replace a single comma with a dot and strip any additional dots so that
 * "1,234.56" becomes "1234.56" and "1.234,56" becomes "1234.56".  */
export function normalizeAmount(raw: string): string {
  if (!raw) return "";
  // First replace the comma with a dot, then remove every dot that is *not*
  // the last one – this guarantees at most one decimal separator.
  return raw.replace(",", ".").replace(/\.(?=.*\.)/g, "");
}

/** Parse a string amount into a Number (NaN on failure). */
export function parseAmount(raw: string): number {
  return Number(normalizeAmount(raw));
}

/** Validate that the provided amount is a positive number greater than zero.
 * Returns an error message string when invalid, otherwise `undefined`. */
export function validateAmount(raw: string): string | undefined {
  if (!raw.trim()) return "Enter amount";
  const value = parseAmount(raw);
  if (Number.isNaN(value) || value <= 0) return "Enter valid amount greater than 0";
  return undefined;
}
```

### `src/forms/simple-transaction-form/utils/availableCategories.ts`
Computes which categories should appear in the category dropdown based on current form selection.

```ts
// Utility to calculate which categories should be presented in the select list
// depending on current form fields.
import { categoriesData } from "./staticData";
import { SimpleTransactionFormShape } from "./validation";

interface CategoryItem {
  value: string;
  group: string;
}

/**
 * Business rule – filter categories only when `fields.category` is still empty.
 */
export function computeAvailableCategories(fields: SimpleTransactionFormShape): CategoryItem[] {
  const base = [...categoriesData, { value: "other", group: "other" }];

  if (!fields.category && fields.category_group && fields.category_group !== "other") {
    return [
      ...categoriesData.filter((c) => c.group === fields.category_group),
      { value: "other", group: fields.category_group },
    ];
  }

  return base;
}
```

### `src/forms/simple-transaction-form/utils/payload.ts`
Transforms validated form data into the JSON payload required by the backend API.

```ts
import { SimpleTransactionFormShape } from "./validation";
import { normalizeAmount } from "./amount";

interface SimpleTransactionPayload {
  transaction_type: string;
  event_type: string;
  account: string;
  category_group: string;
  category: string;
  gross_amount: string;
  business_timestamp: string;
  business_reference?: string;
  item?: string;
  note?: string;
  include_tax?: boolean;
  tax_rate?: number;
  to_account?: string;
}

/**
 * Build API payload adhering to the backend contract. Handles "other" custom
 * fields and amount normalization.
 */
export function buildSimpleTransactionPayload(form: SimpleTransactionFormShape): SimpleTransactionPayload {
  const category_group = form.category_group === "other" ? form.custom_category_group ?? "" : form.category_group;
  const category = form.category === "other" ? form.custom_category ?? "" : form.category;

  let event_type: string;
  let finalCategoryGroup: string = category_group;
  let finalCategory: string = category;

  if (form.transaction_type === "simple_transfer") {
    event_type = "transfer";
    finalCategoryGroup = "internal_transfer";
    finalCategory = "outgoing_transfer";
  } else {
    event_type = form.transaction_type === "simple_expense" ? "cost_paid" : "income_received";
  }

  const payload: SimpleTransactionPayload & { to_account?: string } = {
    transaction_type: form.transaction_type,
    event_type,
    account: form.account,
    category_group: finalCategoryGroup,
    category: finalCategory,
    gross_amount: normalizeAmount(form.gross_amount),
    business_timestamp: form.business_timestamp,
  };

  // Add optional fields only if they have values
  if (form.business_reference?.trim()) {
    payload.business_reference = form.business_reference;
  }
  if (form.item?.trim()) {
    payload.item = form.item;
  }
  if (form.note?.trim()) {
    payload.note = form.note;
  }
  if (form.transaction_type !== "simple_transfer" && form.include_tax) {
    payload.include_tax = form.include_tax;
    payload.tax_rate = form.tax_rate;
  }

  if (form.transaction_type === "simple_transfer") {
    payload.to_account = form.to_account ?? "";
  }

  return payload;
}
```

### `src/forms/simple-transaction-form/utils/staticData.ts`
Static lookup tables for category metadata, bank accounts, and category-group options.

```ts
// Categories mapped to their group
export const categoriesData = [
  // cogs_printing
  { value: "calendar", group: "cogs_printing" },
  { value: "mug_330", group: "cogs_printing" },
  { value: "mug_590", group: "cogs_printing" },
  { value: "shipping_reflect", group: "cogs_printing" },
  { value: "tshirt_black", group: "cogs_printing" },
  { value: "tshirt_white", group: "cogs_printing" },

  // cogs
  { value: "prowizje_bramki", group: "cogs" },

  // opex
  { value: "ads", group: "opex" },
  { value: "biuro", group: "opex" },
  { value: "car_cost", group: "opex" },
  { value: "car_leasing", group: "opex" },
  { value: "credit_line_cost", group: "opex" },
  { value: "credit_line_payment", group: "opex" },
  { value: "equipment", group: "opex" },
  { value: "leasing", group: "opex" },
  { value: "loan_cost", group: "opex" },
  { value: "loan_payment", group: "opex" },
  { value: "other_opex", group: "opex" },
  { value: "owner_payment", group: "opex" },
  { value: "reconciliation", group: "opex" },
  { value: "services", group: "opex" },
  { value: "shipping", group: "opex" },
  { value: "software", group: "opex" },
  { value: "trade_fair", group: "opex" },
  { value: "transport", group: "opex" },

  // taxes
  { value: "vat", group: "taxes" },
  { value: "zus", group: "taxes" },
] as const;

export type CategoryGroupValue = typeof categoriesData[number]["group"];
export type CategoryValue = typeof categoriesData[number]["value"];

// List of available bank / cash accounts
export const accounts = [
  { value: "mbank_firmowe", label: "mbank_firmowe" },
  { value: "mbank_osobiste", label: "mbank_osobiste" },
  { value: "cash", label: "cash" },
  { value: "sumup", label: "sumup" },
] as const;

// High-level category groups for expenses (plus "other")
export const categoryGroups = [
  { value: "cogs_printing", label: "cogs_printing" },
  { value: "cogs", label: "cogs" },
  { value: "opex", label: "opex" },
  { value: "taxes", label: "taxes" },
  { value: "other", label: "other" },
] as const;
```

### `src/forms/simple-transaction-form/utils/syncCategory.ts`
Bidirectional synchronisation logic between the `category` and `category_group` fields.

```ts
import { SimpleTransactionFormShape } from "./validation";

export type FieldKey = keyof SimpleTransactionFormShape;

/**
 * Bidirectional category ↔ category_group synchronisation.
 *
 * When the `category` field changes we auto-set `category_group` based on
 * static mapping. If the `category_group` field changes **after** a category
 * has already been chosen, we now allow the pair to become temporarily
 * "inconsistent" – we no longer clear the selected `category` automatically.
 *
 * Returns the *mutated copy* of the provided form object (does not mutate the
 * original).
 */
export function syncCategory(
  form: SimpleTransactionFormShape,
  field: FieldKey,
  value: string,
  getGroupForCategory: (category: string) => string | undefined,
  ): SimpleTransactionFormShape {
  const next = { ...form, [field]: value } as SimpleTransactionFormShape;

  if (field === "category" && value) {
    const deducedGroup = getGroupForCategory(value);
    // Do NOT override `category_group` when the user intentionally selected "other" –
    // they may have entered a custom group name that must be preserved.
    if (deducedGroup && next.category_group !== "other") {
      next.category_group = deducedGroup;
    }
  }

  // NOTE: previously we cleared `category` when `category_group` changed and
  // became incompatible. Business feedback (2025-06-26) requires keeping the
  // selected category intact, so we intentionally **do nothing** here.

  return next;
}
```

### `src/forms/simple-transaction-form/utils/validation.ts`
Central synchronous validation for the entire form; returns an error map.

```ts
import { validateAmount } from "./amount";

export interface SimpleTransactionFormShape {
  account: string;
  category_group: string;
  category: string;
  gross_amount: string;
  business_timestamp: string;
  transaction_type: string;
  custom_category_group?: string;
  custom_category?: string;
  include_tax: boolean;
  tax_rate: number;
  business_reference?: string;
  item?: string;
  note?: string;
  to_account?: string;
}

/**
 * Validate a transaction form. Returns a map of field names to error
 * messages. An *empty* object means the form is valid.
 */
export function validateSimpleTransactionForm(fields: SimpleTransactionFormShape): Record<string, string> {
  const errors: Record<string, string> = {};

  if (!fields.account.trim()) errors.account = "Select account";

  // Transfer-specific rules
  const isTransfer = fields.transaction_type === "simple_transfer";

  if (isTransfer) {
    if (!fields.to_account?.trim()) errors.to_account = "Select destination account";
    if (fields.to_account && fields.to_account === fields.account) {
      errors.to_account = "From and To accounts must differ";
    }
  } else {
    // Expense / income rules – validate categories
    const finalCategoryGroup = fields.category_group === "other" ? fields.custom_category_group ?? "" : fields.category_group;
    const finalCategory = fields.category === "other" ? fields.custom_category ?? "" : fields.category;

    if (!finalCategoryGroup.trim()) errors.category_group = "Select or enter category group";
    if (!finalCategory.trim()) errors.category = "Select or enter category";
  }

  if (!fields.business_timestamp.trim()) errors.business_timestamp = "Select date";

  const amountError = validateAmount(fields.gross_amount);
  if (amountError) errors.gross_amount = amountError;

  return errors;
}

// TODO: Deprecated – kept temporarily for legacy test suite.
export const validateExpenseForm = validateSimpleTransactionForm;
```

---

## Unit test suite

### `src/forms/simple-transaction-form/__tests__/amount.test.ts`
Tests for amount parsing/validation logic.

```ts
/// <reference types="jest" />

import { normalizeAmount, parseAmount, validateAmount } from "../utils/amount";

describe("amount utils", () => {
  it("normalizes comma decimal to dot", () => {
    expect(normalizeAmount("123,45")).toBe("123.45");
  });

  it("strips thousands separators", () => {
    expect(normalizeAmount("1.234,56")).toBe("1234.56");
  });

  it("parses amount to number", () => {
    expect(parseAmount("99,99")).toBeCloseTo(99.99);
  });

  it("validateAmount detects empty", () => {
    expect(validateAmount("")).toBe("Enter amount");
  });

  it("validateAmount detects zero/negative", () => {
    expect(validateAmount("0,00")).toBe("Enter valid amount greater than 0");
  });

  it("validateAmount passes valid amount", () => {
    expect(validateAmount("12,34")).toBeUndefined();
  });
});
```

### `src/forms/simple-transaction-form/__tests__/availableCategories.test.ts`
Ensures category-filtering logic reflects current form state.

```ts
/// <reference types="jest" />

import { computeAvailableCategories } from "../utils/availableCategories";
import { SimpleTransactionFormShape } from "../utils/validation";

// Minimal fields helper
const baseForm: SimpleTransactionFormShape = {
  account: "a",
  category_group: "opex",
  category: "",
  gross_amount: "10,00",
  business_timestamp: "2025-01-01",
  transaction_type: "some_type",
  include_tax: false,
  tax_rate: 0,
};

describe("computeAvailableCategories", () => {
  it("filters to chosen group when category is empty", () => {
    const list = computeAvailableCategories({ ...baseForm });
    const distinctGroups = new Set(list.map((c) => c.group));
    expect(distinctGroups.size).toBe(1);
    expect([...distinctGroups][0]).toBe("opex");
  });

  it("returns full list when category is already chosen", () => {
    const list = computeAvailableCategories({ ...baseForm, category: "ads" });
    // We expect at least one element from another group (e.g., "taxes")
    const hasOtherGroup = list.some((c) => c.group !== "opex");
    expect(hasOtherGroup).toBe(true);
  });
});
```

### `src/forms/simple-transaction-form/__tests__/syncCategory.test.ts`
Verifies the two-way sync rules between category and category group.

```ts
// Jest globals are available via ts-jest configuration
/// <reference types="jest" />

import { syncCategory } from "../utils/syncCategory";
import type { SimpleTransactionFormShape } from "../utils/validation";

describe("syncCategory", () => {
  const getGroup = (cat: string) => {
    const map: Record<string, string> = {
      ads: "opex",
      vat: "taxes",
    };
    return map[cat];
  };

  it("sets category_group when category changes", () => {
    const form: SimpleTransactionFormShape = {
      account: "a",
      category_group: "",
      category: "",
      gross_amount: "10,00",
      business_timestamp: "2025-01-01",
      transaction_type: "simple_expense",
      include_tax: false,
      tax_rate: 23,
    };
    const next = syncCategory(form, "category", "ads", getGroup);
    expect(next.category_group).toBe("opex");
  });

  it("keeps category intact when category_group changes to a different one", () => {
    const form: SimpleTransactionFormShape = {
      account: "a",
      category_group: "opex",
      category: "ads",
      gross_amount: "10,00",
      business_timestamp: "2025-01-01",
      transaction_type: "simple_expense",
      include_tax: false,
      tax_rate: 23,
    };
    const next = syncCategory(form, "category_group", "taxes", getGroup);
    expect(next.category).toBe("ads");
  });

  it("does not override category_group when group is 'other'", () => {
    const form: SimpleTransactionFormShape = {
      account: "a",
      category_group: "other",
      custom_category_group: "my_custom_grp",
      category: "ads", // initial category doesn't matter
      gross_amount: "10,00",
      business_timestamp: "2025-01-01",
      transaction_type: "simple_expense",
      include_tax: false,
      tax_rate: 23,
    };

    // User changes category to something else
    const next = syncCategory(form, "category", "vat", getGroup);
    expect(next.category_group).toBe("other");
    expect(next.custom_category_group).toBe("my_custom_grp");
  });
});
```

### `src/forms/simple-transaction-form/__tests__/validation.test.ts`
Legacy tests for the validation layer (alias kept for backwards compatibility).

```ts
/// <reference types="jest" />

import { validateExpenseForm } from "../utils/validation";

describe("validateExpenseForm", () => {
  const base = {
    account: "mbank_osobiste",
    category_group: "opex",
    category: "ads",
    gross_amount: "10,00",
    business_timestamp: "2025-01-01",
  } as const;

  it("returns empty errors when form valid", () => {
    expect(validateExpenseForm({ ...base })).toEqual({});
  });

  it("flags missing account", () => {
    const errors = validateExpenseForm({ ...base, account: "" });
    expect(errors.account).toBe("Select account");
  });

  it("flags missing amount", () => {
    const errors = validateExpenseForm({ ...base, gross_amount: "" });
    expect(errors.gross_amount).toBe("Enter amount");
  });
});
```

---

## Shared type declarations

### `src/types/declarations.d.ts`
Ambient module declarations for non-TS libraries used in tests or the app.

```ts
declare module 'react-day-picker';
declare module 'date-fns';
```

### `src/types/transactions.ts`
Standalone interface and error-map types for simple transaction entities.

```ts
export interface SimpleTransactionInput {
  id?: string;
  date: string; // ISO yyyy-mm-dd
  category_group: string;
  category: string;
  description: string;
  amount: string; // Polish comma decimal
}

export type SimpleTransactionErrorMap = Record<keyof SimpleTransactionInput, string | undefined>;
```

---

*End of documentation.*
